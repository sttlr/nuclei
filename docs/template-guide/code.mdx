# Code Protocol (unreleased)

Nuclei enables the execution of external code on the host operating system. This feature allows security researchers, pentesters, and developers to extend the capabilities of Nuclei and perform complex actions beyond the scope of regular supported protocol-based testing.

By leveraging this capability, Nuclei can interact with the underlying operating system and execute custom scripts or commands, opening up a wide range of possibilities. It enables users to perform tasks such as system-level configurations, file operations, network interactions, and more. This level of control and flexibility empowers users to tailor their security testing workflows according to their specific requirements.

However, it's important to exercise caution while utilizing this feature, as executing external code on the host operating system carries inherent risks. It is crucial to ensure that the executed code is secure, thoroughly tested, and does not pose any unintended consequences or security risks to the target system.

Due to the potential for abuse of the template with the code protocol running arbitrary code on the user's system, **unsigned code templates are disabled and cannot be executed.** Only signed code templates can be run with Nuclei. This is a strict measure implemented to enhance the security and trust in the template ecosystem.

Templates that are added to the public [nuclei-templates](https://github.com/projectdiscovery/nuclei-templates) project will be automatically signed by the projectdiscovery team once they have been reviewed and merged into the repository. For private or custom templates, users have the ability to sign the templates themselves using their own private-public key pair.

### Code Template Structure

In the context of template creation, a code block is used to indicate the start of the requests for the template. This block marks the beginning of the code-related instructions.

```yaml
# Start the requests for the template right here
code:
```

To execute the code, a list of engines / interpreter is specified, which are searched sequentially until a valid one is found on the system. The engine names must match the corresponding binary names on the system.

```yaml
- engine:
    - py
    - python3
```

The code to be executed can be provided either as an external file or as a code snippet directly within the template.

For an external file:

```yaml
source: helpers/code/pyfile.py
```

For a code snippet:
```yaml
source: |
      import base64
      message = "payload_string"
      message_bytes = message.encode('ascii')
      base64_bytes = base64.b64encode(message_bytes)
      base64_message = base64_bytes.decode('ascii')
      print(base64_message)
```

The output of the executed code, which is **available for further processing in matchers, extractors, and in other protocol requests**, is represented by the body part in the Code protocol. This body part includes all data printed to stdout during the code execution.

### Matchers / Extractor Parts

Valid `part` values supported by **Code** protocol for Matchers / Extractor are and used as default - 
    
| Part             | Description                        |
|------------------|------------------------------------|
| body             | All data printed from stdout       |


### Example Code Template

The provided example demonstrates the execution of a Python script within the template. The specified engines are searched in the given order, and the code snippet is executed accordingly. Additionally, a matcher is included to check if the code's stdout contains the phrase "hello from input." (input must be passed as target with nuclei)

```yaml
id: code-template-example

info:
  name: code template example
  author: pdteam
  severity: info

self-contained: true
code:
  - engine:
      - bash
      - sh
    source: |
      aws s3 ls

    extractors:
      - type: dsl
        dsl:
          - response
# digest: 34ff9b030101095369676e617475726501ff9c0001030106466f726d6174010c000104426c6f62010a00010452657374010a000000fe0190ff9c01077373682d72736101fe01802394c6aeac1fc86089191fc5261e8c62e904c67595eb6dcb1097ebe71ccfbab591568032af0a68d41ee3f6deae7751686475ced0583d349617d617f10cdca317c9010dba9b9109568394913c5bc5afdb2e964aabc09e52dff43a7060d449a70f8a05dff92983f3858ac3a19de5cd0f5cbed78bbd1e4fb32df61e7d4f1ae194ad63f78f9df9bdd969abf194e82fa30e7efdd434e4494a18d50e7e3f685d1e0a9b1e6ebd02487c745e4d695d09badbb74fd7a429c24b24f7cc56ac481dcf1fb2c52c4391fbf7dddffb01e7b306f63dee208dd269b0b38b066eb2a485ebee9a3e2da16c343b36dbe9b436451e145b48eb809bde6597df82f0f66603af723afbb403f0c71b96d0a803a84217a7d829b37f0ef19c8476a5376b07b2d0f37e9808dc8b32322149f309944857eeb20a619fd8e94faa2b8a77039a28fd4a55bcac1b308ee2a2978421bf4a0eb49e2e2b88a4a40aeb4e7f1779b6c7f1963dfbff3a49d450840ca2afae565ed5e7354807903e8ce3a018fb34fcef6f4fdea0a6feddc09e9400
```

```bash
nuclei -t code_template.yaml

                     __     _
   ____  __  _______/ /__  (_)
  / __ \/ / / / ___/ / _ \/ /
 / / / / /_/ / /__/ /  __/ /
/_/ /_/\__,_/\___/_/\___/_/   v3.0.0-dev

		projectdiscovery.io

[INF] Current nuclei version: v3.0.0-dev (development)
[INF] Current nuclei-templates version: v9.6.2 (latest)
[INF] New templates added in latest release: 61
[INF] Templates loaded for current scan: 1
[code-template-example] [code] [info]  [2022-10-12 19:50:09 alpha-test
2022-11-24 21:23:48 template-data
2023-04-28 21:32:36 oss-test
2022-02-01 17:05:53 test-nuclei]
```

## Template Signing

Template signing via the private-public key mechanism is a crucial aspect of ensuring the integrity and authenticity of templates. This mechanism involves the use of asymmetric cryptography, specifically RSA and ECDSA algorithms, to create a secure and verifiable signature.

In this process, a template author generates a private key that remains confidential and securely stored. The corresponding public key is then shared with the template consumers. When a template is created or modified, the author signs it using their private key, generating a unique signature that is attached to the template.

Template consumers can verify the authenticity and integrity of a signed template by using the author's public key. By applying the appropriate cryptographic algorithm (RSA or ECDSA), they can validate the signature and ensure that the template has not been tampered with since it was signed. This provides a level of trust, as any modifications or unauthorized changes to the template would result in a failed verification process.

By employing the private-public key mechanism, template signing adds an additional layer of security and trust to the template ecosystem. It helps establish the identity of the template author and ensures that the templates used in various systems are genuine and have not been altered maliciously.

### How to sign a template?

First it's necessary to generate a private/public key pair. You need `openssl`. Here follows the commands for the two supported signature algorithms

#### Generate key

```bash
# ECDSA
$ openssl ecparam -name prime256v1 -genkey -noout -out nuclei_sign_private_ecdsa.pem
$ openssl ec -in nuclei_sign_private.pem -pubout > nuclei_sign_public_ecdsa.pem
```

```bash
# RSA
$ ssh-keygen -t rsa
```
#### Configure key

Then these keys need to be exported as environment variables:
```bash
# OSX + Linux
export NUCLEI_SIGNATURE_PRIVATE_KEY=path/to/private.key
export NUCLEI_SIGNATURE_PUBLIC_KEY=path/to/public.key
export NUCLEI_SIGNATURE_ALGORITHM=rsa

# Windows
$env:NUCLEI_SIGNATURE_PRIVATE_KEY='path/to/private.key'
$env:NUCLEI_SIGNATURE_PUBLIC_KEY='path/to/public.key'
$env:NUCLEI_SIGNATURE_ALGORITHM='rsa'
```
#### Sign Template

Finally a template can be signed either with the `v2/cmd/sign-templates` utility or directly with nuclei with the following commands:
```bash
# sign template with nuclei
nuclei -t code_template.yaml -sign

# sign template sign-templates utility
go run -v github.com/projectdiscovery/nuclei/v2/cmd/sign-templates -t code_template.yaml -prk path/to/private.key -puk path/to/public.key -a rsa
```

This will add a comment at the bottom of the template containing the hash signature:
```yaml
# digest: 4a0a00473045022023beecb1c4ef5b3b3a4d936a689d0fa5fea35524d23bbc12001fa0b21ca2500b02210082484d006ee0663ba1c8450ff0d10eb053308137af25cde223406c3423c4e5d1
```